#include <algorithm>
#include <cstring>
#include <ostream>

#include <cppnet/ip_address.hpp>
#include <cppnet/log.hpp>
#include <cppnet/packet.hpp>
#include <cppnet/tcp_socket.hpp>
#include <socket_impl.hpp>

#ifdef _MSC_VER
#pragma warning(disable : 4127) // "conditional expression is constant" generated by the FD_SET macro
#endif


namespace
{
// Define the low-level send/receive flags, which depend on the OS
#ifdef CPPNET_PLATFORM_LINUX
const int flags = MSG_NOSIGNAL;
#else
const int flags = 0;
#endif
} // namespace

namespace cppnet
{
////////////////////////////////////////////////////////////
TcpSocket::TcpSocket() : Socket(Type::TCP)
{
}


////////////////////////////////////////////////////////////
unsigned short TcpSocket::get_local_port() const
{
    if (get_handle() != priv::SocketImpl::invalid_socket())
    {
        // Retrieve informations about the local end of the socket
        sockaddr_in                  address;
        priv::SocketImpl::AddrLength size = sizeof(address);
        if (getsockname(get_handle(), reinterpret_cast<sockaddr*>(&address), &size) != -1)
        {
            return ntohs(address.sin_port);
        }
    }

    // We failed to retrieve the port
    return 0;
}


////////////////////////////////////////////////////////////
std::optional<IpAddress> TcpSocket::get_remote_address() const
{
    if (get_handle() != priv::SocketImpl::invalid_socket())
    {
        // Retrieve informations about the remote end of the socket
        sockaddr_in                  address;
        priv::SocketImpl::AddrLength size = sizeof(address);
        if (getpeername(get_handle(), reinterpret_cast<sockaddr*>(&address), &size) != -1)
        {
            return IpAddress(ntohl(address.sin_addr.s_addr));
        }
    }

    // We failed to retrieve the address
    return std::nullopt;
}


////////////////////////////////////////////////////////////
unsigned short TcpSocket::get_remote_port() const
{
    if (get_handle() != priv::SocketImpl::invalid_socket())
    {
        // Retrieve informations about the remote end of the socket
        sockaddr_in                  address;
        priv::SocketImpl::AddrLength size = sizeof(address);
        if (getpeername(get_handle(), reinterpret_cast<sockaddr*>(&address), &size) != -1)
        {
            return ntohs(address.sin_port);
        }
    }

    // We failed to retrieve the port
    return 0;
}


////////////////////////////////////////////////////////////
Socket::Status TcpSocket::connect(const IpAddress& remote_address, unsigned short remote_port, Time timeout)
{
    // Disconnect the socket if it is already connected
    disconnect();

    // Create the internal socket if it doesn't exist
    create();

    // Create the remote address
    sockaddr_in address = priv::SocketImpl::create_address(remote_address.to_integer(), remote_port);

    if (timeout <= 0s)
    {
        // ----- We're not using a timeout: just try to connect -----

        // Connect the socket
        if (::connect(get_handle(), reinterpret_cast<sockaddr*>(&address), sizeof(address)) == -1)
            return priv::SocketImpl::get_error_status();

        // Connection succeeded
        return Status::Done;
    }
    else
    {
        // ----- We're using a timeout: we'll need a few tricks to make it work -----

        // Save the previous blocking state
        bool blocking = is_blocking();

        // Switch to non-blocking to enable our connection timeout
        if (blocking)
            set_blocking(false);

        // Try to connect to the remote address
        if (::connect(get_handle(), reinterpret_cast<sockaddr*>(&address), sizeof(address)) >= 0)
        {
            // We got instantly connected! (it may no happen a lot...)
            set_blocking(blocking);
            return Status::Done;
        }

        // Get the error status
        Status status = priv::SocketImpl::get_error_status();

        // If we were in non-blocking mode, return immediately
        if (!blocking)
            return status;

        // Otherwise, wait until something happens to our socket (success, timeout or error)
        if (status == Socket::Status::NotReady)
        {
            // Setup the selector
            fd_set selector;
            FD_ZERO(&selector);
            FD_SET(get_handle(), &selector);

            // Setup the timeout
            timeval time;
            time.tv_sec  = static_cast<long>(std::chrono::duration_cast<std::chrono::microseconds>(timeout).count() / 1000000);
            time.tv_usec = static_cast<int>(std::chrono::duration_cast<std::chrono::microseconds>(timeout).count() % 1000000);

            // Wait for something to write on our socket (which means that the connection request has returned)
            if (select(static_cast<int>(get_handle() + 1), nullptr, &selector, nullptr, &time) > 0)
            {
                // At this point the connection may have been either accepted or refused.
                // To know whether it's a success or a failure, we must check the address of the connected peer
                if (get_remote_address().has_value())
                {
                    // Connection accepted
                    status = Status::Done;
                }
                else
                {
                    // Connection refused
                    status = priv::SocketImpl::get_error_status();
                }
            }
            else
            {
                // Failed to connect before timeout is over
                status = priv::SocketImpl::get_error_status();
            }
        }

        // Switch back to blocking mode
        set_blocking(true);

        return status;
    }
}


////////////////////////////////////////////////////////////
void TcpSocket::disconnect()
{
    // Close the socket
    close();

    // Reset the pending packet data
    m_pending_packet = PendingPacket();
}


////////////////////////////////////////////////////////////
Socket::Status TcpSocket::send(const void* data, std::size_t size)
{
    if (!is_blocking())
        err() << "Warning: Partial sends might not be handled properly." << std::endl;

    std::size_t sent;

    return send(data, size, sent);
}


////////////////////////////////////////////////////////////
Socket::Status TcpSocket::send(const void* data, std::size_t size, std::size_t& sent)
{
    // Check the parameters
    if (!data || (size == 0))
    {
        err() << "Cannot send data over the network (no data to send)" << std::endl;
        return Status::Error;
    }

    // Loop until every byte has been sent
    int result = 0;
    for (sent = 0; sent < size; sent += static_cast<std::size_t>(result))
    {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuseless-cast"
        // Send a chunk of data
        result = static_cast<int>(
            ::send(get_handle(), static_cast<const char*>(data) + sent, static_cast<priv::SocketImpl::Size>(size - sent), flags));
#pragma GCC diagnostic pop

        // Check for errors
        if (result < 0)
        {
            Status status = priv::SocketImpl::get_error_status();

            if ((status == Status::NotReady) && sent)
                return Status::Partial;

            return status;
        }
    }

    return Status::Done;
}


////////////////////////////////////////////////////////////
Socket::Status TcpSocket::receive(void* data, std::size_t size, std::size_t& received)
{
    // First clear the variables to fill
    received = 0;

    // Check the destination buffer
    if (!data)
    {
        err() << "Cannot receive data from the network (the destination buffer is invalid)" << std::endl;
        return Status::Error;
    }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuseless-cast"
    // Receive a chunk of bytes
    int size_received = static_cast<int>(
        recv(get_handle(), static_cast<char*>(data), static_cast<priv::SocketImpl::Size>(size), flags));
#pragma GCC diagnostic pop

    // Check the number of bytes received
    if (size_received > 0)
    {
        received = static_cast<std::size_t>(size_received);
        return Status::Done;
    }
    else if (size_received == 0)
    {
        return Socket::Status::Disconnected;
    }
    else
    {
        return priv::SocketImpl::get_error_status();
    }
}


////////////////////////////////////////////////////////////
Socket::Status TcpSocket::send(Packet& packet)
{
    // TCP is a stream protocol, it doesn't preserve messages boundaries.
    // This means that we have to send the packet size first, so that the
    // receiver knows the actual end of the packet in the data stream.

    // We allocate an extra memory block so that the size can be sent
    // together with the data in a single call. This may seem inefficient,
    // but it is actually required to avoid partial send, which could cause
    // data corruption on the receiving end.

    // Get the data to send from the packet
    std::size_t size = 0;
    const void* data = packet.on_send(size);

    // First convert the packet size to network byte order
    std::uint32_t packet_size = htonl(static_cast<std::uint32_t>(size));

    // Allocate memory for the data block to send
    m_block_to_send_buffer.resize(sizeof(packet_size) + size);

// Copy the packet size and data into the block to send
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wnull-dereference" // False positive.
    std::memcpy(m_block_to_send_buffer.data(), &packet_size, sizeof(packet_size));
#pragma GCC diagnostic pop
    if (size > 0)
        std::memcpy(m_block_to_send_buffer.data() + sizeof(packet_size), data, size);

// These warnings are ignored here for portability, as even on Windows the
// signature of `send` might change depending on whether Win32 or MinGW is
// being used.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuseless-cast"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-conversion"
    // Send the data block
    std::size_t sent;
    Status      status = send(m_block_to_send_buffer.data() + packet.m_send_pos,
                         static_cast<priv::SocketImpl::Size>(m_block_to_send_buffer.size() - packet.m_send_pos),
                         sent);
#pragma GCC diagnostic pop
#pragma GCC diagnostic pop

    // In the case of a partial send, record the location to resume from
    if (status == Status::Partial)
    {
        packet.m_send_pos += sent;
    }
    else if (status == Status::Done)
    {
        packet.m_send_pos = 0;
    }

    return status;
}


////////////////////////////////////////////////////////////
Socket::Status TcpSocket::receive(Packet& packet)
{
    // First clear the variables to fill
    packet.clear();

    // We start by getting the size of the incoming packet
    std::uint32_t packet_size = 0;
    std::size_t   received   = 0;
    if (m_pending_packet.size_received < sizeof(m_pending_packet.size))
    {
        // Loop until we've received the entire size of the packet
        // (even a 4 byte variable may be received in more than one call)
        while (m_pending_packet.size_received < sizeof(m_pending_packet.size))
        {
            char*  data   = reinterpret_cast<char*>(&m_pending_packet.size) + m_pending_packet.size_received;
            Status status = receive(data, sizeof(m_pending_packet.size) - m_pending_packet.size_received, received);
            m_pending_packet.size_received += received;

            if (status != Status::Done)
                return status;
        }

        // The packet size has been fully received
        packet_size = ntohl(m_pending_packet.size);
    }
    else
    {
        // The packet size has already been received in a previous call
        packet_size = ntohl(m_pending_packet.size);
    }

    // Loop until we receive all the packet data
    char buffer[1024];
    while (m_pending_packet.data.size() < packet_size)
    {
        // Receive a chunk of data
        std::size_t size_to_get = std::min(packet_size - m_pending_packet.data.size(), sizeof(buffer));
        Status      status    = receive(buffer, size_to_get, received);
        if (status != Status::Done)
            return status;

        // Append it into the packet
        if (received > 0)
        {
            m_pending_packet.data.resize(m_pending_packet.data.size() + received);
            char* begin = m_pending_packet.data.data() + m_pending_packet.data.size() - received;
            std::memcpy(begin, buffer, received);
        }
    }

    // We have received all the packet data: we can copy it to the user packet
    if (!m_pending_packet.data.empty())
        packet.on_receive(m_pending_packet.data.data(), m_pending_packet.data.size());

    // Clear the pending packet data
    m_pending_packet = PendingPacket();

    return Status::Done;
}

} // namespace cppnet
